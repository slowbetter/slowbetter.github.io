<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hemo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="grow up">
<meta property="og:type" content="website">
<meta property="og:title" content="Hemo">
<meta property="og:url" content="http://slowbetter.cn/index.html">
<meta property="og:site_name" content="Hemo">
<meta property="og:description" content="grow up">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hemo">
<meta name="twitter:description" content="grow up">
  
    <link rel="alternate" href="/atom.xml" title="Hemo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hemo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hemo</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://slowbetter.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-RDD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/RDD/" class="article-date">
  <time datetime="2018-03-07T12:49:54.000Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/RDD/">Spark RDD介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#RDD简介<br>在集群背后，有一个非常重要的分布式数据架构，即弹性分布式数据集（Resilient Distributed Dataset，RDD）。RDD是Spark的最基本抽象,是对分布式内存的抽象使用，实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD是Spark最核心的东西，它表示已被分区，不可变的并能够被并行操作的数据集合，不同的数据集格式对应不同的RDD实现。RDD必须是可序列化的。RDD可以cache到内存中，每次对RDD数据集的操作之后的结果，都可以存放到内存中，下一个操作可以直接从内存中输入，省去了MapReduce大量的磁盘IO操作。这对于迭代运算比较常见的机器学习算法, 交互式数据挖掘来说，效率提升比较大。</p>
<p>##RDD的特点</p>
<ul>
<li>创建：只能通过转换从稳定存储中的数据或者其他RDD</li>
<li>只读：状态不可变，不能修改</li>
<li>分区：根据key来分区</li>
<li>路径：世族或血统，RDD有信息显示他从其他RDD产生而来</li>
<li>持久化：支持将会被重用的RDD缓存</li>
<li>延迟计算，管道化</li>
<li>操作：转换transformation和动作count/reduce/collect/save</li>
</ul>
<p>##RDD的好处</p>
<ul>
<li>更高效实现容错，无需checkpoint</li>
<li>RDD的 不变性可以实现Hadoop的MR的推测式执行</li>
<li>RDD都是可序列化的</li>
<li>批量操作，数据本地性。</li>
</ul>
<p>##RDD的内部属性<br>通过RDD的内部属性，用户可以获取相应的元数据信息。通过这些信息可以支持更复杂的算法或优化</p>
<ul>
<li>分区列表</li>
<li>计算分片的函数</li>
<li>对父RDD的依赖列表</li>
<li>key-value型的RDD是根据哈希来分区的，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce</li>
<li>每一个分片的优先计算位置（preferred locations），比如HDFS的block的所在位置应该是优先计算的位置。(存储的是一个表，可以将处理的分区“本地化”)</li>
</ul>
<p>##存储与分区</p>
<ul>
<li>用户可以选择不同的存储级别存储RDD以便重用。RDD根据useDisk、useMemory、useOffHeap、deserialized、replication参数的组合定义存储级别</li>
<li>当前RDD默认是存储于内存，但当内存不足时，RDD会spill到disk</li>
<li>RDD在需要进行分区把数据分布于集群中时会根据每条记录Key进行分区（如Hash 分区），以此保证两个数据集在Join时能高效</li>
</ul>
<p>##容错机制</p>
<ul>
<li>RDD的容错机制实现分布式数据集容错方法有两种：数据检查点和记录更新</li>
<li>RDD的容错机制又称“血统”容错。 要实现这种“血统”容错机制，最大的难题就是如何表达父RDD和子RDD之间的依赖关系</li>
<li>依赖关系可以分两种，窄依赖和宽依赖。窄依赖：子RDD中的每个数据块只依赖于父RDD中对应的有限个固定的数据块；宽依赖：子RDD中的一个数据块可以依赖于父RDD中的所有数据块。</li>
<li>在“血统”链特别是有宽依赖的时候，需要在适当的时机设置数据检查点。也是这两个特性要求对于不同依赖关系要采取不同的任务调度机制和容错恢复机制。</li>
</ul>
<p>##Spark计算工作流</p>
<ul>
<li>算子是RDD中定义的函数，可以对RDD中的数据进行转换和操作。</li>
<li>输入：在Spark程序运行中，数据从外部数据空间（例如，HDFS、Scala集合或数据）输入到Spark，数据就进入了Spark运行时数据空间，会转化为Spark中的数据块，通过BlockManager进行管理。</li>
<li>运行：在Spark数据输入形成RDD后，便可以通过变换算子fliter等，对数据操作并将RDD转化为新的RDD，通过行动（Action）算子，触发Spark提交作业。如果数据需要复用，可以通过Cache算子，将数据缓存到内存。</li>
<li>输出：程序运行结束数据会输出Spark运行时空间，存储到分布式存储中（如saveAsTextFile输出到HDFS）或Scala数据或集合中（collect输出到Scala集合，count返回Scala Int型数据）。<br><img src="http://img.blog.csdn.net/20160623111913455" alt="算子和数据空间"></li>
<li>Spark的核心数据模型是RDD，但RDD是个抽象类，具体由各子类实现，如MappedRDD、ShuffledRDD等子类。Spark将常用的大数据操作都转化成为RDD的子类。</li>
</ul>
<p>##编程模型</p>
<ul>
<li>输入算子将Scala集合类型或存储中的数据吸入RDD空间，转为RDD。输入算子的输入大致有两类：一类针对 Scala集合类型，如parallelize；另一类针对存储数据，如上例中的textFile。输入算子的输出就是Spark空间的RDD。</li>
<li>因为函数语义，RDD经过变换（transformation）算子生成新的RDD。变换算子的输入和输出都是RDD。</li>
<li>从RDD到RDD的变换算子序列，一直在RDD空间发生。这里很重要的设计是lazy evaluation：计算并不实际发生，只是不断地记录到元数据。元数据的结构是DAG（有向无环图），其中每一个“顶点”是RDD（包括生产该RDD 的算子），从父RDD到子RDD有“边”，表示RDD间的依赖性。Spark给元数据DAG取了个很酷的名字，Lineage（世系）。这个 Lineage也是前面容错设计中所说的日志更新。</li>
<li>Lineage一直增长，直到遇上行动（action）算子，这时 就要evaluate了，把刚才累积的所有算子一次性执行。行动算子的输入是RDD（以及该RDD在Lineage上依赖的所有RDD），输出是执行后生 成的原生数据，可能是Scala标量、集合类型的数据或存储。当一个算子的输出是上述类型时，该算子必然是行动算子，其效果则是从RDD空间返回原生数据空间。</li>
</ul>
<p>##运行逻辑</p>
<ul>
<li>在Spark应用中，整个执行流程在逻辑上运算之间会形成有向无环图。</li>
</ul>
<p>##依赖关系</p>
<ul>
<li>Stage划分的依据就是宽依赖，什么时候产生宽依赖呢？例如reduceByKey，groupByKey等Action。</li>
<li>从后往前推理，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到Stage中</li>
<li>每个Stage里面的Task的数量是由该Stage中最后一个RDD的Partition数量决定的</li>
<li>最后一个Stage里面的任务的类型是ResultTask，前面所有其他Stage里面的任务类型都是ShuffleMapTask</li>
<li>代表当前Stage的算子一定是该Stage的最后一个计算步骤<br>##RDD如何操作<br>###RDD的创建方式</li>
<li>从Hadoop文件系统（或与Hadoop兼容的其他持久化存储系统，如Hive、Cassandra、HBase）输入（例如HDFS）创建</li>
<li>从父RDD转换得到新RDD</li>
<li>通过parallelize或makeRDD将单机数据创建为分布式RDD<br>###RDD的两种操作算子</li>
<li>转换（Transformation）：Transformation操作是延迟计算的，也就是说从一个RDD转换生成另一个RDD的转换操作不是马上执行，需要等到有Action操作的时候才会真正触发运算</li>
<li>行动（Action）：Action算子会触发Spark提交作业（Job），并将数据输出Spark系统</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160622191518541" alt="转换"><br><img src="http://img.blog.csdn.net/20160622192016312" alt="行动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/07/RDD/" data-id="cjesags540005g6se9yyyvmpl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RDD/">RDD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/">spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python_ml" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/python_ml/" class="article-date">
  <time datetime="2018-03-07T12:49:54.000Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/python_ml/">机器学习算法Python居多</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#机器学习算法python居多</p>
<ul>
<li>解释型语言，减少开发者工作量。简单易学，比较接地气</li>
<li>python有很多第三方数学运算库，NumPy、SciPy。可视化方面有MatplotLib和SeaBorn，结构化数据操作可以通过Pandas。对各种垂直领域比如图像、语音、文本在预处理阶段都有很多城市的库可以调用。事实上学术界和工业界的目的是不一致的！学术界所探讨的是可能性问题，而工业界是实现性问题。所以，学术界的代码灵活性很高！经常提出新的想法和实现，如果c++实现的不好改框架是三天两头的事情。</li>
<li>无法满足大规模训练。一般用python搭建原型，然后用C++或者JAVA实现工程化。</li>
<li>深度学习框架的设计者，caffe选择了python，torch选择了lua(一个应用于游戏的脚本语言)，tensorflow选择了python。随着深度学习的如火如荼，一下就把python推向了神坛。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/07/python_ml/" data-id="cjesags5c0006g6ser220gssk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/06/es/" class="article-date">
  <time datetime="2018-03-06T12:49:54.000Z" itemprop="datePublished">2018-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/06/es/">ES知识梳理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##带着问题上路——ES是如何产生的？</p>
<p>###思考：大规模数据如何检索？<br>如：当系统数据量上了10亿、100亿条的时候，我们在做系统架构的时候通常会从以下角度去考虑问题： </p>
<ol>
<li>用什么数据库好？(mysql、sybase、oracle、达梦、神通、mongodb、hbase…) </li>
<li>如何解决单点故障；(lvs、F5、A10、Zookeep、MQ) </li>
<li>如何保证数据安全性；(热备、冷备、异地多活) </li>
<li>如何解决检索难题；(数据库代理中间件：mysql-proxy、Cobar、MaxScale等;) </li>
<li>如何解决统计分析问题；(离线、近实时)</li>
</ol>
<p>###传统数据库的应对解决方案<br>对于关系型数据，我们通常采用以下或类似架构去解决查询瓶颈和写入瓶颈：<br>解决要点： </p>
<ol>
<li>通过主从备份解决数据安全性问题； </li>
<li>通过数据库代理中间件心跳监测，解决单点故障问题； </li>
<li>通过代理中间件将查询语句分发到各个slave节点进行查询，并汇总结果<br>这里写图片描述</li>
</ol>
<p>###非关系型数据库的解决方案<br>对于Nosql数据库，以mongodb为例，其它原理类似：<br>解决要点： </p>
<ol>
<li>通过副本备份保证数据安全性； </li>
<li>通过节点竞选机制解决单点问题； </li>
<li>先从配置库检索分片信息，然后将请求分发到各个节点，最后由路由节点合并汇总结果 </li>
</ol>
<p>###另辟蹊径——完全把数据放入内存怎么样？<br>我们知道，完全把数据放在内存中是不可靠的，实际上也不太现实，当我们的数据达到PB级别时，按照每个节点96G内存计算，在内存完全装满的数据情况下，我们需要的机器是：1PB=1024T=1048576G<br>节点数=1048576/96=10922个<br>实际上，考虑到数据备份，节点数往往在2.5万台左右。成本巨大决定了其不现实！</p>
<p>从前面讨论我们了解到，把数据放在内存也好，不放在内存也好，都不能完完全全解决问题。<br>全部放在内存速度问题是解决了，但成本问题上来了。<br>为解决以上问题，从源头着手分析，通常会从以下方式来寻找方法：<br>1、存储数据时按有序存储；<br>2、将数据和索引分离；<br>3、压缩数据；<br>这就引出了Elasticsearch。</p>
<h2 id="ES-基础一网打尽"><a href="#ES-基础一网打尽" class="headerlink" title="ES 基础一网打尽"></a>ES 基础一网打尽</h2><h3 id="ES定义"><a href="#ES定义" class="headerlink" title="ES定义"></a>ES定义</h3><p>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<h3 id="Lucene与ES关系？"><a href="#Lucene与ES关系？" class="headerlink" title="Lucene与ES关系？"></a>Lucene与ES关系？</h3><p>1）Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p>
<p>2）Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<p>###ES主要解决问题：<br>1）检索相关数据；<br>2）返回统计结果；<br>3）速度要快。</p>
<p>###ES工作原理<br>当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。这个过程如下图所示： </p>
<h3 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h3><p>1）Cluster：集群。<br>ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。</p>
<p>2）Node：节点。<br>形成集群的每个服务器称为节点。</p>
<p>3）Shard：分片。<br>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。<br>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p>
<p>4）Replia：副本。<br>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p>
<p>5）全文检索。<br>全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。<br>全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。</p>
<h3 id="ES数据架构的主要概念（与关系数据库Mysql对比）"><a href="#ES数据架构的主要概念（与关系数据库Mysql对比）" class="headerlink" title="ES数据架构的主要概念（与关系数据库Mysql对比）"></a>ES数据架构的主要概念（与关系数据库Mysql对比）</h3><ul>
<li>关系型数据库中的数据库（DataBase），等价于ES中的索引（Index） </li>
<li>一个数据库下面有N张表（Table），等价于1个索引Index下面有N多类型（Type）， </li>
<li>一个数据库表（Table）下的数据由多行（ROW）多列（column，属性）组成，等价于1个Type由多个文档（Document）和多Field组成。 </li>
<li>在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。 </li>
<li>在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET.<br><img src="http://img.blog.csdn.net/20160818210034345" alt=""><h3 id="ELK是什么？"><a href="#ELK是什么？" class="headerlink" title="ELK是什么？"></a>ELK是什么？</h3>ELK=elasticsearch+Logstash+kibana<br>elasticsearch：后台分布式存储以及全文检索<br>logstash: 日志加工、“搬运工”<br>kibana：数据可视化展示。<br>ELK架构为数据分布式存储、可视化查询和日志解析创建了一个功能强大的管理链。 三者相互配合，取长补短，共同完成分布式大数据处理工作。</li>
</ul>
<h2 id="ES特点和优势"><a href="#ES特点和优势" class="headerlink" title="ES特点和优势"></a>ES特点和优势</h2><p>1）分布式实时文件存储，可将每一个字段存入索引，使其可以被检索到。<br>2）实时分析的分布式搜索引擎。<br>分布式：索引分拆成多个分片，每个分片可有零个或多个副本。集群中的每个数据节点都可承载一个或多个分片，并且协调和处理各种操作；<br>负载再平衡和路由在大多数情况下自动完成。<br>3）可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。也可以运行在单台PC上（已测试）<br>4）支持插件机制，分词插件、同步插件、Hadoop插件、可视化插件等。</p>
<p>##ES性能<br>3.1 性能结果展示<br>（1）硬件配置：<br>CPU 16核 AuthenticAMD<br>内存 总量：32GB<br>硬盘 总量：500GB 非SSD</p>
<p>（2）在上述硬件指标的基础上测试性能如下：<br>1）平均索引吞吐量： 12307docs/s（每个文档大小：40B/docs）<br>2）平均CPU使用率： 887.7%（16核，平均每核：55.48%）<br>3）构建索引大小： 3.30111 GB<br>4）总写入量： 20.2123 GB<br>5）测试总耗时： 28m 54s.</p>
<h3 id="性能esrally工具（推荐）"><a href="#性能esrally工具（推荐）" class="headerlink" title="性能esrally工具（推荐）"></a>性能esrally工具（推荐）</h3><p>使用参考<a href="：http://blog.csdn.net/laoyang360/article/details/52155481">：http://blog.csdn.net/laoyang360/article/details/52155481</a></p>
<p>##为什么要用ES？</p>
<h3 id="ES国内外使用优秀案例"><a href="#ES国内外使用优秀案例" class="headerlink" title="ES国内外使用优秀案例"></a>ES国内外使用优秀案例</h3><p>1） 2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”。</p>
<p>2）维基百科：启动以elasticsearch为基础的核心搜索架构。<br>3）SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”。<br>4）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据。</p>
<h3 id="我们也需要"><a href="#我们也需要" class="headerlink" title="我们也需要"></a>我们也需要</h3><p>实际项目开发实战中，几乎每个系统都会有一个搜索的功能，当搜索做到一定程度时，维护和扩展起来难度就会慢慢变大，所以很多公司都会把搜索单独独立出一个模块，用ElasticSearch等来实现。</p>
<p>近年ElasticSearch发展迅猛，已经超越了其最初的纯搜索引擎的角色，现在已经增加了数据聚合分析（aggregation）和可视化的特性，如果你有数百万的文档需要通过关键词进行定位时，ElasticSearch肯定是最佳选择。当然，如果你的文档是JSON的，你也可以把ElasticSearch当作一种“NoSQL数据库”， 应用ElasticSearch数据聚合分析（aggregation）的特性，针对数据进行多维度的分析。</p>
<p>【知乎：热酷架构师潘飞】ES在某些场景下替代传统DB<br>个人以为Elasticsearch作为内部存储来说还是不错的，效率也基本能够满足，在某些方面替代传统DB也是可以的，前提是你的业务不对操作的事性务有特殊要求；而权限管理也不用那么细，因为ES的权限这块还不完善。<br>由于我们对ES的应用场景仅仅是在于对某段时间内的数据聚合操作，没有大量的单文档请求（比如通过userid来找到一个用户的文档，类似于NoSQL的应用场景），所以能否替代NoSQL还需要各位自己的测试。<br>如果让我选择的话，我会尝试使用ES来替代传统的NoSQL，因为它的横向扩展机制太方便了。</p>
<h2 id="ES的应用场景是怎样的？"><a href="#ES的应用场景是怎样的？" class="headerlink" title="ES的应用场景是怎样的？"></a>ES的应用场景是怎样的？</h2><p>通常我们面临问题有两个：<br>1）新系统开发尝试使用ES作为存储和检索服务器；<br>2）现有系统升级需要支持全文检索服务，需要使用ES。<br>以上两种架构的使用，以下链接进行详细阐述。<br><a href="http://blog.csdn.net/laoyang360/article/details/52227541" target="_blank" rel="noopener">http://blog.csdn.net/laoyang360/article/details/52227541</a></p>
<p>一线公司ES使用场景：</p>
<ul>
<li>新浪ES 如何分析处理32亿条实时日志 <a href="http://dockone.io/article/505" target="_blank" rel="noopener">http://dockone.io/article/505</a> </li>
<li>阿里ES 构建挖财自己的日志采集和分析体系 <a href="http://afoo.me/columns/tec/logging-platform-spec.html" target="_blank" rel="noopener">http://afoo.me/columns/tec/logging-platform-spec.html</a> </li>
<li>有赞ES 业务日志处理 <a href="http://tech.youzan.com/you-zan-tong-ri-zhi-ping-tai-chu-tan/" target="_blank" rel="noopener">http://tech.youzan.com/you-zan-tong-ri-zhi-ping-tai-chu-tan/</a> </li>
<li>ES实现站内搜索 <a href="http://www.wtoutiao.com/p/13bkqiZ.html" target="_blank" rel="noopener">http://www.wtoutiao.com/p/13bkqiZ.html</a></li>
</ul>
<h2 id="如何部署ES？"><a href="#如何部署ES？" class="headerlink" title="如何部署ES？"></a>如何部署ES？</h2><h3 id="ES部署（无需安装）"><a href="#ES部署（无需安装）" class="headerlink" title="ES部署（无需安装）"></a>ES部署（无需安装）</h3><p>1）零配置，开箱即用<br>2）没有繁琐的安装配置<br>3）java版本要求：最低1.7<br>我使用的1.8<br>[root@laoyang config_lhy]# echo $JAVA_HOME<br>/opt/jdk1.8.0_91<br>4）下载地址：<br><a href="https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/zip/elasticsearch/2.3.5/elasticsearch-2.3.5.zip" target="_blank" rel="noopener">https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/zip/elasticsearch/2.3.5/elasticsearch-2.3.5.zip</a><br>5）启动<br>cd /usr/local/elasticsearch-2.3.5<br>./bin/elasticsearch<br>bin/elasticsearch -d(后台运行)</p>
<h3 id="ES必要的插件"><a href="#ES必要的插件" class="headerlink" title="ES必要的插件"></a>ES必要的插件</h3><p>必要的Head、kibana、IK（中文分词）、graph等插件的详细安装和使用。<br><a href="http://blog.csdn.net/column/details/deep-elasticsearch.html" target="_blank" rel="noopener">http://blog.csdn.net/column/details/deep-elasticsearch.html</a></p>
<h3 id="ES-windows下一键安装"><a href="#ES-windows下一键安装" class="headerlink" title="ES windows下一键安装"></a>ES windows下一键安装</h3><p>自写bat脚本实现windows下一键安装。<br>1）一键安装ES及必要插件（head、kibana、IK、logstash等）<br>2）安装后以服务形式运行ES。<br>3）比自己摸索安装节省至少2小时时间，效率非常高。<br>脚本说明：<br><a href="http://blog.csdn.net/laoyang360/article/details/51900235" target="_blank" rel="noopener">http://blog.csdn.net/laoyang360/article/details/51900235</a></p>
<h3 id="ES对外接口（开发人员关注）"><a href="#ES对外接口（开发人员关注）" class="headerlink" title="ES对外接口（开发人员关注）"></a>ES对外接口（开发人员关注）</h3><p>1）JAVA API接口<br><a href="http://www.ibm.com/developerworks/library/j-use-elasticsearch-java-apps/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/library/j-use-elasticsearch-java-apps/index.html</a></p>
<p>2）RESTful API接口<br>常见的增、删、改、查操作实现：<br><a href="http://blog.csdn.net/laoyang360/article/details/51931981" target="_blank" rel="noopener">http://blog.csdn.net/laoyang360/article/details/51931981</a></p>
<p>##ES遇到问题怎么办？<br>1）国外：<a href="https://discuss.elastic.co/" target="_blank" rel="noopener">https://discuss.elastic.co/</a><br>2）国内：<a href="http://elasticsearch.cn/" target="_blank" rel="noopener">http://elasticsearch.cn/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/06/es/" data-id="cjesags4o0000g6see02i1rhl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/检索/">检索</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/redis/" class="article-date">
  <time datetime="2018-03-05T12:49:54.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/缓存/">缓存</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/redis/">redis数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#redis常用的数据类型</p>
<ul>
<li>String 正常的key，正常的value，序列化和反序列化</li>
<li>Hash 正常的key，HashMap(filed，value)代表对</li>
<li>List key是链表名字，每个子元素都是string类型的双向链表</li>
<li>Set Set名字，String类型无序集合</li>
<li>Zset Zset名字，一列value，一列存顺序</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/05/redis/" data-id="cjesags5g000ag6setp4lkob9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习计划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/学习计划/" class="article-date">
  <time datetime="2018-03-04T12:49:54.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/学习计划/">学习计划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="3月计划"><a href="#3月计划" class="headerlink" title="3月计划"></a>3月计划</h2><h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><ul>
<li>深入理解java虚拟机</li>
<li>effective java<h3 id="学习大数据"><a href="#学习大数据" class="headerlink" title="学习大数据"></a>学习大数据</h3></li>
<li>storm</li>
<li>spark</li>
<li>elasticSearch</li>
<li>flink</li>
<li>esper</li>
<li>druid</li>
<li>kafka<h3 id="学习常用组件"><a href="#学习常用组件" class="headerlink" title="学习常用组件"></a>学习常用组件</h3></li>
<li>mysql</li>
<li>redis</li>
<li>spring</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/04/学习计划/" data-id="cjesags5f0009g6see23r5z49" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计划/">计划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/Effective-Java/" class="article-date">
  <time datetime="2018-03-04T00:26:37.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/Effective-Java/">Effective Java</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h3><ul>
<li>有名称，易用</li>
<li>避免创建新对象，重复利用。</li>
<li>返回子类型对象，更大灵活性。服务提供者框架的基础</li>
<li>参数化类型实例，使代码变动更加简洁</li>
<li>静态工厂方法API文档没标识，常见的命名：valueOf，of，getInstance，newInstance，getType，newType</li>
</ul>
<h3 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h3><ul>
<li>多参数，可变参数，一开始就是要构建器</li>
</ul>
<h3 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化Singleton属性</h3><ul>
<li>单元素的枚举类型已经成为实现singleton的最佳方法</li>
<li>反序列化，所有实例域都是瞬时的，并提供readResolve方法</li>
</ul>
<h3 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h3><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><ul>
<li>避免new String(“str”)</li>
<li>优先使用基本类型而不是装箱基本类型</li>
</ul>
<h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><ul>
<li>一个栈先增后缩，那么从栈中弹出来的对象将不会被当做垃圾回收，过期引用：永远不会再被解除的引用。</li>
<li>只要类是自己管理内存的，程序员就应该警惕内存泄漏</li>
<li>缓存，WeakHashMap</li>
<li>监听器和其他回调。</li>
</ul>
<h3 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h3><ul>
<li>性能损失</li>
<li>不能保证被及时的执行，不要依赖终结方法来关闭</li>
<li>显示终止方法必须子啊一个私有域中记录“该对象已经不再有效”</li>
<li>终结方法充当安全网</li>
<li>本地对等体需要终结方法</li>
<li>终结方法链不会被自动执行，子类必须手工调用超类的终结方法，终结方法守卫者</li>
</ul>
<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><h3 id="覆盖equals时请遵守通用约定"><a href="#覆盖equals时请遵守通用约定" class="headerlink" title="覆盖equals时请遵守通用约定"></a>覆盖equals时请遵守通用约定</h3><ul>
<li>对称性、传递性、一致性、自反性、非空</li>
</ul>
<h3 id="覆盖equals时总要覆盖hashCode"><a href="#覆盖equals时总要覆盖hashCode" class="headerlink" title="覆盖equals时总要覆盖hashCode"></a>覆盖equals时总要覆盖hashCode</h3><ul>
<li>无法与基于散列的集合一起正常使用</li>
<li>相等的实例有着相同的散列，不相同的实例尽量有不同散列</li>
</ul>
<h3 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h3><ul>
<li>易于理解，但格式要一直保持<h3 id="谨慎的覆盖clone"><a href="#谨慎的覆盖clone" class="headerlink" title="谨慎的覆盖clone"></a>谨慎的覆盖clone</h3></li>
<li>拷贝构造器和静态工厂方法的变形，都比Cloneable更具优势<h3 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h3></li>
</ul>
<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><h3 id="在共有类中使用访问方法而非公有域"><a href="#在共有类中使用访问方法而非公有域" class="headerlink" title="在共有类中使用访问方法而非公有域"></a>在共有类中使用访问方法而非公有域</h3><h3 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h3><h3 id="复合优先于继承"><a href="#复合优先于继承" class="headerlink" title="复合优先于继承"></a>复合优先于继承</h3><ul>
<li>跨包边界的继承是非常危险的</li>
<li>继承打破了封装性</li>
<li>用复合和转发机制代替</li>
<li>包装类比子类更具健壮，而且功能更加强大</li>
<li>包装类不适合用在回调框架中，被包装的对象不知道他外面的包装对象，所以传递一个指向自身的引用，回调时避开了外面的包装对象。</li>
</ul>
<h3 id="要么为继承二设计，并提供文档说明，要么禁止继承"><a href="#要么为继承二设计，并提供文档说明，要么禁止继承" class="headerlink" title="要么为继承二设计，并提供文档说明，要么禁止继承"></a>要么为继承二设计，并提供文档说明，要么禁止继承</h3><ul>
<li>可覆盖的方法，即非final的，公有的货受保护的</li>
<li>文档说明该方法或者构造器调用了那些可覆盖的方法</li>
<li>好的API文档应该描述一个给定的方法做了什么，而不是描述他如何做到的。</li>
<li>禁止子类化，final或者构造器编程私有，并用静态工厂方法。</li>
<li>确保这个类永远不会调用他的任何可覆盖方法。</li>
<li>消除可覆盖方法的自用特性，而不改变他的行为——转移到私有的“辅助方法”</li>
</ul>
<h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><ul>
<li>接口是定义混合类型的理想选择</li>
<li>接口允许构造非层次结构的类型框架，组合爆炸</li>
<li>演变的容易性比灵活性和功能更为重要的时候，用抽象类</li>
<li>骨架实现类接管所有与接口实现相关的工作。</li>
<li>模拟多重继承</li>
</ul>
<h3 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h3><h3 id="类层次优于标签类"><a href="#类层次优于标签类" class="headerlink" title="类层次优于标签类"></a>类层次优于标签类</h3><ul>
<li>标签类，枚举声明、标签域</li>
<li>标签类过于冗长，容易出错，效率低下</li>
</ul>
<h3 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h3><ul>
<li>函数只指针的主要用途就是实现策略模式</li>
<li>单次使用则用匿名类，重复使用则用私有的静态成员类<h3 id="优先考虑静态成员类"><a href="#优先考虑静态成员类" class="headerlink" title="优先考虑静态成员类"></a>优先考虑静态成员类</h3></li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="请不要在新代码中使用原生态类型"><a href="#请不要在新代码中使用原生态类型" class="headerlink" title="请不要在新代码中使用原生态类型"></a>请不要在新代码中使用原生态类型</h3><ul>
<li>失掉了泛型在安全性和表述性方面的优势</li>
</ul>
<h3 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h3><h3 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h3><ul>
<li>数组是协变切可以具体化的，泛型是不可变的切可以被擦除的。</li>
<li>数组提供的运行时类型安全，但是没有编译时的类型安全。泛型相反</li>
</ul>
<h3 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h3><ul>
<li>使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全</li>
</ul>
<h3 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h3><ul>
<li>静态工具方法尤其适合泛型化</li>
</ul>
<h3 id="利用有限制通配符来提升API的灵活性"><a href="#利用有限制通配符来提升API的灵活性" class="headerlink" title="利用有限制通配符来提升API的灵活性"></a>利用有限制通配符来提升API的灵活性</h3><ul>
<li>PECS，所有的comparable和comparator消费者</li>
</ul>
<h3 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h3><ul>
<li>将键进行参数化而不是将容器参数化<h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><h3 id="用enum代替int常量"><a href="#用enum代替int常量" class="headerlink" title="用enum代替int常量"></a>用enum代替int常量</h3></li>
<li>安全，易读，功能更加强大</li>
<li>如果多个枚举常量同时共享相同行为，则考虑枚举策略。枚举策略传到枚举构造器中，形成嵌套枚举</li>
<li>枚举中的抽象方法</li>
<li>枚举toString</li>
</ul>
<h3 id="用实例域代替序数"><a href="#用实例域代替序数" class="headerlink" title="用实例域代替序数"></a>用实例域代替序数</h3><ul>
<li>永远不要根据枚举的序数导出与它关联的值，要保存在一个实例域中。<h3 id="用EnumSet代替位域"><a href="#用EnumSet代替位域" class="headerlink" title="用EnumSet代替位域"></a>用EnumSet代替位域</h3></li>
<li>EnumSet集位域的简洁和性能优势</li>
<li>1.6 无法创建不可变的EnumSet。可以用Collections.unmodifiableSet将EnumSet封装起来<h3 id="用EnumMap代替序数索引"><a href="#用EnumMap代替序数索引" class="headerlink" title="用EnumMap代替序数索引"></a>用EnumMap代替序数索引</h3></li>
<li>一般都不使用Enum.ordinal</li>
<li>多维就用EnumMap&lt;…,EnumMap&lt;…&gt;&gt;</li>
</ul>
<h3 id="用接口模拟可伸缩的枚举"><a href="#用接口模拟可伸缩的枚举" class="headerlink" title="用接口模拟可伸缩的枚举"></a>用接口模拟可伸缩的枚举</h3><h3 id="注解优先于命名模式"><a href="#注解优先于命名模式" class="headerlink" title="注解优先于命名模式"></a>注解优先于命名模式</h3><h3 id="坚持使用Override注解"><a href="#坚持使用Override注解" class="headerlink" title="坚持使用Override注解"></a>坚持使用Override注解</h3><h3 id="用标记接口定义类型"><a href="#用标记接口定义类型" class="headerlink" title="用标记接口定义类型"></a>用标记接口定义类型</h3><ul>
<li>标记接口，没有方法的声明的接口。</li>
<li>标记注解，扩展性好。</li>
<li>标记接口，编译时捕捉到错误。精确锁定。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="检查参数的有效性"><a href="#检查参数的有效性" class="headerlink" title="检查参数的有效性"></a>检查参数的有效性</h3><h3 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h3><h3 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h3><h3 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h3><h3 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h3><h3 id="返回零长度的数组或者集合，而不是null"><a href="#返回零长度的数组或者集合，而不是null" class="headerlink" title="返回零长度的数组或者集合，而不是null"></a>返回零长度的数组或者集合，而不是null</h3><h3 id="为所有导出的API元素编写文档注释"><a href="#为所有导出的API元素编写文档注释" class="headerlink" title="为所有导出的API元素编写文档注释"></a>为所有导出的API元素编写文档注释</h3><h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><h3 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h3><h3 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h3><ul>
<li>通过完全隐藏迭代器和索引变量，避免了混乱和出错的可能</li>
<li>列外 过滤，转换，平行迭代</li>
</ul>
<h3 id="了解和使用类库"><a href="#了解和使用类库" class="headerlink" title="了解和使用类库"></a>了解和使用类库</h3><h3 id="如果需要精确的答案，避免使用float和double"><a href="#如果需要精确的答案，避免使用float和double" class="headerlink" title="如果需要精确的答案，避免使用float和double"></a>如果需要精确的答案，避免使用float和double</h3><ul>
<li>小数，BigDecimal，超过18位</li>
</ul>
<h3 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h3><ul>
<li>基本类型：简单，快速</li>
<li>装箱基本类型用法：集合中，参数化类型，反射的方法调用。</li>
</ul>
<h3 id="如果其他类型更合适，避免使用字符串"><a href="#如果其他类型更合适，避免使用字符串" class="headerlink" title="如果其他类型更合适，避免使用字符串"></a>如果其他类型更合适，避免使用字符串</h3><ul>
<li>字符串更加笨拙，更不灵活，速度更慢，更容易出错</li>
<li>替代方案，基本类型，枚举类型和聚集类型。</li>
</ul>
<h3 id="当心字符串连接的性能"><a href="#当心字符串连接的性能" class="headerlink" title="当心字符串连接的性能"></a>当心字符串连接的性能</h3><ul>
<li>StringBuilder 可以预先初始化</li>
</ul>
<h3 id="通过接口引用对象"><a href="#通过接口引用对象" class="headerlink" title="通过接口引用对象"></a>通过接口引用对象</h3><ul>
<li>灵活</li>
<li>列外：值类String，基于类的框架TimerTask，类中有接口以外的方法LinkedHashMap。</li>
</ul>
<h3 id="接口优先于反射机制"><a href="#接口优先于反射机制" class="headerlink" title="接口优先于反射机制"></a>接口优先于反射机制</h3><ul>
<li>反射，丧失了编译时类型检查的好处，笨拙冗长，性能损失。</li>
<li>反射使用场景，编写的程序必须要与编译时未知的类一起工作。</li>
</ul>
<h3 id="谨慎的使用本地方法"><a href="#谨慎的使用本地方法" class="headerlink" title="谨慎的使用本地方法"></a>谨慎的使用本地方法</h3><ul>
<li>本地方法不安全，JVM已经很快了。</li>
</ul>
<h3 id="谨慎的进行优化"><a href="#谨慎的进行优化" class="headerlink" title="谨慎的进行优化"></a>谨慎的进行优化</h3><ul>
<li>首先检查算法的选择</li>
</ul>
<h3 id="遵守命名惯例"><a href="#遵守命名惯例" class="headerlink" title="遵守命名惯例"></a>遵守命名惯例</h3><ul>
<li>字面的和语法的</li>
<li>用户的包不能以java开头</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="只针对异常的情况才使用异常"><a href="#只针对异常的情况才使用异常" class="headerlink" title="只针对异常的情况才使用异常"></a>只针对异常的情况才使用异常</h3><ul>
<li>不要用于控制流</li>
</ul>
<h3 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><ul>
<li>用运行时异常来表明编程错误</li>
<li>如果不清楚是否可能恢复，最好使用未受检的异常。</li>
</ul>
<h3 id="避免不必要的使用受检异常"><a href="#避免不必要的使用受检异常" class="headerlink" title="避免不必要的使用受检异常"></a>避免不必要的使用受检异常</h3><h3 id="优先使用标准异常"><a href="#优先使用标准异常" class="headerlink" title="优先使用标准异常"></a>优先使用标准异常</h3><h3 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h3><ul>
<li>异常转译</li>
<li>异常链，高层通过getClause来获得底层的异常。</li>
</ul>
<h3 id="每个方法抛出的异常都要有文档"><a href="#每个方法抛出的异常都要有文档" class="headerlink" title="每个方法抛出的异常都要有文档"></a>每个方法抛出的异常都要有文档</h3><h3 id="在细节消息中包含能捕获失败的信息"><a href="#在细节消息中包含能捕获失败的信息" class="headerlink" title="在细节消息中包含能捕获失败的信息"></a>在细节消息中包含能捕获失败的信息</h3><h3 id="努力使失败保持原子性"><a href="#努力使失败保持原子性" class="headerlink" title="努力使失败保持原子性"></a>努力使失败保持原子性</h3><ul>
<li>如果做不到，就在API文档中说明</li>
</ul>
<h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="同步方法共享的可变数据"><a href="#同步方法共享的可变数据" class="headerlink" title="同步方法共享的可变数据"></a>同步方法共享的可变数据</h3><h3 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h3><ul>
<li>为了避免死锁和数据破坏，前往不要从同步预期内部调用外来的方法。尽量限制同步区域的工作量。</li>
<li>类是线程安全的。通过内部同步获得更高的并发性。<h3 id="exector和task优先于线程"><a href="#exector和task优先于线程" class="headerlink" title="exector和task优先于线程"></a>exector和task优先于线程</h3></li>
<li>Executros</li>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor</li>
<li><h3 id="并发工具优先于wait和notify"><a href="#并发工具优先于wait和notify" class="headerlink" title="并发工具优先于wait和notify"></a>并发工具优先于wait和notify</h3></li>
<li>编程复杂，低效。</li>
</ul>
<h3 id="线程安全性的文档化"><a href="#线程安全性的文档化" class="headerlink" title="线程安全性的文档化"></a>线程安全性的文档化</h3><ul>
<li>不可变，String、Long、BigInteger</li>
<li>无条件的线程安全，Random、ConcurrentHashMap</li>
<li>有条件的线程安全，Collections.synchronized包装返回的结合，他们的迭代器邀请外部同步。</li>
<li>非线程安全。ArrayList和HashMap</li>
<li>线程对立</li>
</ul>
<h3 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h3><ul>
<li>双重检查模式</li>
</ul>
<h3 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h3><h3 id="避免使用线程组"><a href="#避免使用线程组" class="headerlink" title="避免使用线程组"></a>避免使用线程组</h3><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="谨慎地实现Serializable接口"><a href="#谨慎地实现Serializable接口" class="headerlink" title="谨慎地实现Serializable接口"></a>谨慎地实现Serializable接口</h3><ul>
<li>一旦发布，就降低了改变的灵活性</li>
<li>增加出现bug和安全漏洞的可能</li>
<li>随着发布新的版本，测试负担增加了</li>
<li>内部类不应该实现Serializable，内部类的默认序列化形式是定义不清楚的。</li>
<li>序列版本UID<h3 id="考虑使用自定义的序列化形式"><a href="#考虑使用自定义的序列化形式" class="headerlink" title="考虑使用自定义的序列化形式"></a>考虑使用自定义的序列化形式</h3><h3 id="保护性地编写readObject"><a href="#保护性地编写readObject" class="headerlink" title="保护性地编写readObject"></a>保护性地编写readObject</h3><h3 id="对于实例控制，枚举类型优先于readResolve"><a href="#对于实例控制，枚举类型优先于readResolve" class="headerlink" title="对于实例控制，枚举类型优先于readResolve"></a>对于实例控制，枚举类型优先于readResolve</h3><h3 id="考虑用序列化代理代替序列化实例"><a href="#考虑用序列化代理代替序列化实例" class="headerlink" title="考虑用序列化代理代替序列化实例"></a>考虑用序列化代理代替序列化实例</h3></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/04/Effective-Java/" data-id="cjesags520004g6seh9zndai9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解java虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/03/深入理解java虚拟机/" class="article-date">
  <time datetime="2018-03-03T12:49:54.000Z" itemprop="datePublished">2018-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/03/深入理解java虚拟机/">深入理解java虚拟机</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="走近java"><a href="#走近java" class="headerlink" title="走近java"></a>走近java</h2><ul>
<li>java技术体系的过去、现在和未来</li>
<li>独立编译OpenJDK7</li>
</ul>
<h2 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h2><ul>
<li>虚拟机的内存是如何划分的。</li>
<li>什么样的代码和操作可能导致内存溢出异常</li>
<li>垃圾回收的算法和垃圾收集器的特点和运作原理</li>
<li>命令行工具和可视化故障处理工具</li>
<li>案例</li>
</ul>
<h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><ul>
<li>class文件的结构和各个组成部分，每个部分定义、数据结构和使用方法，class文件如何存储和访问</li>
<li>类加载过程的加载、验证、准备、解析、和初始化虚拟机分别执行了哪些动作。类加载器的工作原理及对虚拟机的意义</li>
<li>虚拟机在执行代码时如何找到正确的方法，如何执行方法内的字节码，以及执行代码时涉及的内存结构</li>
<li>4个类加载器及执行子系统，使用类加载器和处理字节码的一些值得欣赏和借鉴到思路。</li>
</ul>
<h2 id="程序编译和代码优化"><a href="#程序编译和代码优化" class="headerlink" title="程序编译和代码优化"></a>程序编译和代码优化</h2><ul>
<li>范型、主动装箱和拆箱、条件编译等多种语法糖等前因后果。注解检测程序命名规范</li>
<li>讲解虚拟机的热点探测方法、HotSpot的即时编译器，编译触发条件。如何从虚拟机的外部观察和分析JIT编译的数据和结构。常见的编译优化技术。</li>
</ul>
<h2 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h2><ul>
<li>虚拟机内存模型的结构和操作，原子性和可见性、有序性。先行发生原则的规则及使用，线程在java语言中时如何实现的。</li>
<li>线程安全，锁优化，同步实现的方式和虚拟机底层运作的原理。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/03/深入理解java虚拟机/" data-id="cjesags5l000eg6sez0hp8dr9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/概述/">概述</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟机/">虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/03/hexo教程/" class="article-date">
  <time datetime="2018-03-03T12:14:28.000Z" itemprop="datePublished">2018-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hexo教程/">Hexo教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/03/hexo教程/">hexo教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>内容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/03/hexo教程/" data-id="cjesags4u0001g6seouxn36ck" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博客/">博客</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo教程/">Hexo教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/缓存/">缓存</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDD/">RDD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/检索/">检索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概述/">概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟机/">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/RDD/" style="font-size: 10px;">RDD</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spark/" style="font-size: 10px;">spark</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/检索/" style="font-size: 10px;">检索</a> <a href="/tags/概述/" style="font-size: 10px;">概述</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/虚拟机/" style="font-size: 10px;">虚拟机</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/07/RDD/">Spark RDD介绍</a>
          </li>
        
          <li>
            <a href="/2018/03/07/python_ml/">机器学习算法Python居多</a>
          </li>
        
          <li>
            <a href="/2018/03/06/es/">ES知识梳理</a>
          </li>
        
          <li>
            <a href="/2018/03/05/redis/">redis数据结构</a>
          </li>
        
          <li>
            <a href="/2018/03/04/学习计划/">学习计划</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 hfq<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>