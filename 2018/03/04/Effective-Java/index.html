<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Effective Java | Hemo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="创建和销毁对象考虑用静态工厂方法代替构造器 有名称，易用 避免创建新对象，重复利用。 返回子类型对象，更大灵活性。服务提供者框架的基础 参数化类型实例，使代码变动更加简洁 静态工厂方法API文档没标识，常见的命名：valueOf，of，getInstance，newInstance，getType，newType  遇到多个构造器参数时要考虑用构建器 多参数，可变参数，一开始就是要构建器  用私有">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Java">
<meta property="og:url" content="http://slowbetter.cn/2018/03/04/Effective-Java/index.html">
<meta property="og:site_name" content="Hemo">
<meta property="og:description" content="创建和销毁对象考虑用静态工厂方法代替构造器 有名称，易用 避免创建新对象，重复利用。 返回子类型对象，更大灵活性。服务提供者框架的基础 参数化类型实例，使代码变动更加简洁 静态工厂方法API文档没标识，常见的命名：valueOf，of，getInstance，newInstance，getType，newType  遇到多个构造器参数时要考虑用构建器 多参数，可变参数，一开始就是要构建器  用私有">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-09T14:06:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Java">
<meta name="twitter:description" content="创建和销毁对象考虑用静态工厂方法代替构造器 有名称，易用 避免创建新对象，重复利用。 返回子类型对象，更大灵活性。服务提供者框架的基础 参数化类型实例，使代码变动更加简洁 静态工厂方法API文档没标识，常见的命名：valueOf，of，getInstance，newInstance，getType，newType  遇到多个构造器参数时要考虑用构建器 多参数，可变参数，一开始就是要构建器  用私有">
  
    <link rel="alternate" href="/atom.xml" title="Hemo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hemo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hemo</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://slowbetter.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Effective-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/Effective-Java/" class="article-date">
  <time datetime="2018-03-04T00:26:37.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Effective Java
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h3><ul>
<li>有名称，易用</li>
<li>避免创建新对象，重复利用。</li>
<li>返回子类型对象，更大灵活性。服务提供者框架的基础</li>
<li>参数化类型实例，使代码变动更加简洁</li>
<li>静态工厂方法API文档没标识，常见的命名：valueOf，of，getInstance，newInstance，getType，newType</li>
</ul>
<h3 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h3><ul>
<li>多参数，可变参数，一开始就是要构建器</li>
</ul>
<h3 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化Singleton属性</h3><ul>
<li>单元素的枚举类型已经成为实现singleton的最佳方法</li>
<li>反序列化，所有实例域都是瞬时的，并提供readResolve方法</li>
</ul>
<h3 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h3><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><ul>
<li>避免new String(“str”)</li>
<li>优先使用基本类型而不是装箱基本类型</li>
</ul>
<h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><ul>
<li>一个栈先增后缩，那么从栈中弹出来的对象将不会被当做垃圾回收，过期引用：永远不会再被解除的引用。</li>
<li>只要类是自己管理内存的，程序员就应该警惕内存泄漏</li>
<li>缓存，WeakHashMap</li>
<li>监听器和其他回调。</li>
</ul>
<h3 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h3><ul>
<li>性能损失</li>
<li>不能保证被及时的执行，不要依赖终结方法来关闭</li>
<li>显示终止方法必须子啊一个私有域中记录“该对象已经不再有效”</li>
<li>终结方法充当安全网</li>
<li>本地对等体需要终结方法</li>
<li>终结方法链不会被自动执行，子类必须手工调用超类的终结方法，终结方法守卫者</li>
</ul>
<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><h3 id="覆盖equals时请遵守通用约定"><a href="#覆盖equals时请遵守通用约定" class="headerlink" title="覆盖equals时请遵守通用约定"></a>覆盖equals时请遵守通用约定</h3><ul>
<li>对称性、传递性、一致性、自反性、非空</li>
</ul>
<h3 id="覆盖equals时总要覆盖hashCode"><a href="#覆盖equals时总要覆盖hashCode" class="headerlink" title="覆盖equals时总要覆盖hashCode"></a>覆盖equals时总要覆盖hashCode</h3><ul>
<li>无法与基于散列的集合一起正常使用</li>
<li>相等的实例有着相同的散列，不相同的实例尽量有不同散列</li>
</ul>
<h3 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h3><ul>
<li>易于理解，但格式要一直保持<h3 id="谨慎的覆盖clone"><a href="#谨慎的覆盖clone" class="headerlink" title="谨慎的覆盖clone"></a>谨慎的覆盖clone</h3></li>
<li>拷贝构造器和静态工厂方法的变形，都比Cloneable更具优势<h3 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h3></li>
</ul>
<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><h3 id="在共有类中使用访问方法而非公有域"><a href="#在共有类中使用访问方法而非公有域" class="headerlink" title="在共有类中使用访问方法而非公有域"></a>在共有类中使用访问方法而非公有域</h3><h3 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h3><h3 id="复合优先于继承"><a href="#复合优先于继承" class="headerlink" title="复合优先于继承"></a>复合优先于继承</h3><ul>
<li>跨包边界的继承是非常危险的</li>
<li>继承打破了封装性</li>
<li>用复合和转发机制代替</li>
<li>包装类比子类更具健壮，而且功能更加强大</li>
<li>包装类不适合用在回调框架中，被包装的对象不知道他外面的包装对象，所以传递一个指向自身的引用，回调时避开了外面的包装对象。</li>
</ul>
<h3 id="要么为继承二设计，并提供文档说明，要么禁止继承"><a href="#要么为继承二设计，并提供文档说明，要么禁止继承" class="headerlink" title="要么为继承二设计，并提供文档说明，要么禁止继承"></a>要么为继承二设计，并提供文档说明，要么禁止继承</h3><ul>
<li>可覆盖的方法，即非final的，公有的货受保护的</li>
<li>文档说明该方法或者构造器调用了那些可覆盖的方法</li>
<li>好的API文档应该描述一个给定的方法做了什么，而不是描述他如何做到的。</li>
<li>禁止子类化，final或者构造器编程私有，并用静态工厂方法。</li>
<li>确保这个类永远不会调用他的任何可覆盖方法。</li>
<li>消除可覆盖方法的自用特性，而不改变他的行为——转移到私有的“辅助方法”</li>
</ul>
<h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><ul>
<li>接口是定义混合类型的理想选择</li>
<li>接口允许构造非层次结构的类型框架，组合爆炸</li>
<li>演变的容易性比灵活性和功能更为重要的时候，用抽象类</li>
<li>骨架实现类接管所有与接口实现相关的工作。</li>
<li>模拟多重继承</li>
</ul>
<h3 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h3><h3 id="类层次优于标签类"><a href="#类层次优于标签类" class="headerlink" title="类层次优于标签类"></a>类层次优于标签类</h3><ul>
<li>标签类，枚举声明、标签域</li>
<li>标签类过于冗长，容易出错，效率低下</li>
</ul>
<h3 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h3><ul>
<li>函数只指针的主要用途就是实现策略模式</li>
<li>单次使用则用匿名类，重复使用则用私有的静态成员类<h3 id="优先考虑静态成员类"><a href="#优先考虑静态成员类" class="headerlink" title="优先考虑静态成员类"></a>优先考虑静态成员类</h3></li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="请不要在新代码中使用原生态类型"><a href="#请不要在新代码中使用原生态类型" class="headerlink" title="请不要在新代码中使用原生态类型"></a>请不要在新代码中使用原生态类型</h3><ul>
<li>失掉了泛型在安全性和表述性方面的优势</li>
</ul>
<h3 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h3><h3 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h3><ul>
<li>数组是协变切可以具体化的，泛型是不可变的切可以被擦除的。</li>
<li>数组提供的运行时类型安全，但是没有编译时的类型安全。泛型相反</li>
</ul>
<h3 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h3><ul>
<li>使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全</li>
</ul>
<h3 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h3><ul>
<li>静态工具方法尤其适合泛型化</li>
</ul>
<h3 id="利用有限制通配符来提升API的灵活性"><a href="#利用有限制通配符来提升API的灵活性" class="headerlink" title="利用有限制通配符来提升API的灵活性"></a>利用有限制通配符来提升API的灵活性</h3><ul>
<li>PECS，所有的comparable和comparator消费者</li>
</ul>
<h3 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h3><ul>
<li>将键进行参数化而不是将容器参数化<h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><h3 id="用enum代替int常量"><a href="#用enum代替int常量" class="headerlink" title="用enum代替int常量"></a>用enum代替int常量</h3></li>
<li>安全，易读，功能更加强大</li>
<li>如果多个枚举常量同时共享相同行为，则考虑枚举策略。枚举策略传到枚举构造器中，形成嵌套枚举</li>
<li>枚举中的抽象方法</li>
<li>枚举toString</li>
</ul>
<h3 id="用实例域代替序数"><a href="#用实例域代替序数" class="headerlink" title="用实例域代替序数"></a>用实例域代替序数</h3><ul>
<li>永远不要根据枚举的序数导出与它关联的值，要保存在一个实例域中。<h3 id="用EnumSet代替位域"><a href="#用EnumSet代替位域" class="headerlink" title="用EnumSet代替位域"></a>用EnumSet代替位域</h3></li>
<li>EnumSet集位域的简洁和性能优势</li>
<li>1.6 无法创建不可变的EnumSet。可以用Collections.unmodifiableSet将EnumSet封装起来<h3 id="用EnumMap代替序数索引"><a href="#用EnumMap代替序数索引" class="headerlink" title="用EnumMap代替序数索引"></a>用EnumMap代替序数索引</h3></li>
<li>一般都不使用Enum.ordinal</li>
<li>多维就用EnumMap&lt;…,EnumMap&lt;…&gt;&gt;</li>
</ul>
<h3 id="用接口模拟可伸缩的枚举"><a href="#用接口模拟可伸缩的枚举" class="headerlink" title="用接口模拟可伸缩的枚举"></a>用接口模拟可伸缩的枚举</h3><h3 id="注解优先于命名模式"><a href="#注解优先于命名模式" class="headerlink" title="注解优先于命名模式"></a>注解优先于命名模式</h3><h3 id="坚持使用Override注解"><a href="#坚持使用Override注解" class="headerlink" title="坚持使用Override注解"></a>坚持使用Override注解</h3><h3 id="用标记接口定义类型"><a href="#用标记接口定义类型" class="headerlink" title="用标记接口定义类型"></a>用标记接口定义类型</h3><ul>
<li>标记接口，没有方法的声明的接口。</li>
<li>标记注解，扩展性好。</li>
<li>标记接口，编译时捕捉到错误。精确锁定。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="检查参数的有效性"><a href="#检查参数的有效性" class="headerlink" title="检查参数的有效性"></a>检查参数的有效性</h3><h3 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h3><h3 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h3><h3 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h3><h3 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h3><h3 id="返回零长度的数组或者集合，而不是null"><a href="#返回零长度的数组或者集合，而不是null" class="headerlink" title="返回零长度的数组或者集合，而不是null"></a>返回零长度的数组或者集合，而不是null</h3><h3 id="为所有导出的API元素编写文档注释"><a href="#为所有导出的API元素编写文档注释" class="headerlink" title="为所有导出的API元素编写文档注释"></a>为所有导出的API元素编写文档注释</h3><h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><h3 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h3><h3 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h3><ul>
<li>通过完全隐藏迭代器和索引变量，避免了混乱和出错的可能</li>
<li>列外 过滤，转换，平行迭代</li>
</ul>
<h3 id="了解和使用类库"><a href="#了解和使用类库" class="headerlink" title="了解和使用类库"></a>了解和使用类库</h3><h3 id="如果需要精确的答案，避免使用float和double"><a href="#如果需要精确的答案，避免使用float和double" class="headerlink" title="如果需要精确的答案，避免使用float和double"></a>如果需要精确的答案，避免使用float和double</h3><ul>
<li>小数，BigDecimal，超过18位</li>
</ul>
<h3 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h3><ul>
<li>基本类型：简单，快速</li>
<li>装箱基本类型用法：集合中，参数化类型，反射的方法调用。</li>
</ul>
<h3 id="如果其他类型更合适，避免使用字符串"><a href="#如果其他类型更合适，避免使用字符串" class="headerlink" title="如果其他类型更合适，避免使用字符串"></a>如果其他类型更合适，避免使用字符串</h3><ul>
<li>字符串更加笨拙，更不灵活，速度更慢，更容易出错</li>
<li>替代方案，基本类型，枚举类型和聚集类型。</li>
</ul>
<h3 id="当心字符串连接的性能"><a href="#当心字符串连接的性能" class="headerlink" title="当心字符串连接的性能"></a>当心字符串连接的性能</h3><ul>
<li>StringBuilder 可以预先初始化</li>
</ul>
<h3 id="通过接口引用对象"><a href="#通过接口引用对象" class="headerlink" title="通过接口引用对象"></a>通过接口引用对象</h3><ul>
<li>灵活</li>
<li>列外：值类String，基于类的框架TimerTask，类中有接口以外的方法LinkedHashMap。</li>
</ul>
<h3 id="接口优先于反射机制"><a href="#接口优先于反射机制" class="headerlink" title="接口优先于反射机制"></a>接口优先于反射机制</h3><ul>
<li>反射，丧失了编译时类型检查的好处，笨拙冗长，性能损失。</li>
<li>反射使用场景，编写的程序必须要与编译时未知的类一起工作。</li>
</ul>
<h3 id="谨慎的使用本地方法"><a href="#谨慎的使用本地方法" class="headerlink" title="谨慎的使用本地方法"></a>谨慎的使用本地方法</h3><ul>
<li>本地方法不安全，JVM已经很快了。</li>
</ul>
<h3 id="谨慎的进行优化"><a href="#谨慎的进行优化" class="headerlink" title="谨慎的进行优化"></a>谨慎的进行优化</h3><ul>
<li>首先检查算法的选择</li>
</ul>
<h3 id="遵守命名惯例"><a href="#遵守命名惯例" class="headerlink" title="遵守命名惯例"></a>遵守命名惯例</h3><ul>
<li>字面的和语法的</li>
<li>用户的包不能以java开头</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="只针对异常的情况才使用异常"><a href="#只针对异常的情况才使用异常" class="headerlink" title="只针对异常的情况才使用异常"></a>只针对异常的情况才使用异常</h3><ul>
<li>不要用于控制流</li>
</ul>
<h3 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><ul>
<li>用运行时异常来表明编程错误</li>
<li>如果不清楚是否可能恢复，最好使用未受检的异常。</li>
</ul>
<h3 id="避免不必要的使用受检异常"><a href="#避免不必要的使用受检异常" class="headerlink" title="避免不必要的使用受检异常"></a>避免不必要的使用受检异常</h3><h3 id="优先使用标准异常"><a href="#优先使用标准异常" class="headerlink" title="优先使用标准异常"></a>优先使用标准异常</h3><h3 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h3><ul>
<li>异常转译</li>
<li>异常链，高层通过getClause来获得底层的异常。</li>
</ul>
<h3 id="每个方法抛出的异常都要有文档"><a href="#每个方法抛出的异常都要有文档" class="headerlink" title="每个方法抛出的异常都要有文档"></a>每个方法抛出的异常都要有文档</h3><h3 id="在细节消息中包含能捕获失败的信息"><a href="#在细节消息中包含能捕获失败的信息" class="headerlink" title="在细节消息中包含能捕获失败的信息"></a>在细节消息中包含能捕获失败的信息</h3><h3 id="努力使失败保持原子性"><a href="#努力使失败保持原子性" class="headerlink" title="努力使失败保持原子性"></a>努力使失败保持原子性</h3><ul>
<li>如果做不到，就在API文档中说明</li>
</ul>
<h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="同步方法共享的可变数据"><a href="#同步方法共享的可变数据" class="headerlink" title="同步方法共享的可变数据"></a>同步方法共享的可变数据</h3><h3 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h3><ul>
<li>为了避免死锁和数据破坏，前往不要从同步预期内部调用外来的方法。尽量限制同步区域的工作量。</li>
<li>类是线程安全的。通过内部同步获得更高的并发性。<h3 id="exector和task优先于线程"><a href="#exector和task优先于线程" class="headerlink" title="exector和task优先于线程"></a>exector和task优先于线程</h3></li>
<li>Executros</li>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor</li>
<li><h3 id="并发工具优先于wait和notify"><a href="#并发工具优先于wait和notify" class="headerlink" title="并发工具优先于wait和notify"></a>并发工具优先于wait和notify</h3></li>
<li>编程复杂，低效。</li>
</ul>
<h3 id="线程安全性的文档化"><a href="#线程安全性的文档化" class="headerlink" title="线程安全性的文档化"></a>线程安全性的文档化</h3><ul>
<li>不可变，String、Long、BigInteger</li>
<li>无条件的线程安全，Random、ConcurrentHashMap</li>
<li>有条件的线程安全，Collections.synchronized包装返回的结合，他们的迭代器邀请外部同步。</li>
<li>非线程安全。ArrayList和HashMap</li>
<li>线程对立</li>
</ul>
<h3 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h3><ul>
<li>双重检查模式</li>
</ul>
<h3 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h3><h3 id="避免使用线程组"><a href="#避免使用线程组" class="headerlink" title="避免使用线程组"></a>避免使用线程组</h3><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="谨慎地实现Serializable接口"><a href="#谨慎地实现Serializable接口" class="headerlink" title="谨慎地实现Serializable接口"></a>谨慎地实现Serializable接口</h3><ul>
<li>一旦发布，就降低了改变的灵活性</li>
<li>增加出现bug和安全漏洞的可能</li>
<li>随着发布新的版本，测试负担增加了</li>
<li>内部类不应该实现Serializable，内部类的默认序列化形式是定义不清楚的。</li>
<li>序列版本UID<h3 id="考虑使用自定义的序列化形式"><a href="#考虑使用自定义的序列化形式" class="headerlink" title="考虑使用自定义的序列化形式"></a>考虑使用自定义的序列化形式</h3><h3 id="保护性地编写readObject"><a href="#保护性地编写readObject" class="headerlink" title="保护性地编写readObject"></a>保护性地编写readObject</h3><h3 id="对于实例控制，枚举类型优先于readResolve"><a href="#对于实例控制，枚举类型优先于readResolve" class="headerlink" title="对于实例控制，枚举类型优先于readResolve"></a>对于实例控制，枚举类型优先于readResolve</h3><h3 id="考虑用序列化代理代替序列化实例"><a href="#考虑用序列化代理代替序列化实例" class="headerlink" title="考虑用序列化代理代替序列化实例"></a>考虑用序列化代理代替序列化实例</h3></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://slowbetter.cn/2018/03/04/Effective-Java/" data-id="cjesags520004g6seh9zndai9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/04/学习计划/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          学习计划
        
      </div>
    </a>
  
  
    <a href="/2018/03/03/深入理解java虚拟机/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">深入理解java虚拟机</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo教程/">Hexo教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/缓存/">缓存</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDD/">RDD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/检索/">检索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概述/">概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟机/">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/RDD/" style="font-size: 10px;">RDD</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spark/" style="font-size: 10px;">spark</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/检索/" style="font-size: 10px;">检索</a> <a href="/tags/概述/" style="font-size: 10px;">概述</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/虚拟机/" style="font-size: 10px;">虚拟机</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/07/RDD/">Spark RDD介绍</a>
          </li>
        
          <li>
            <a href="/2018/03/07/python_ml/">机器学习算法Python居多</a>
          </li>
        
          <li>
            <a href="/2018/03/06/es/">ES知识梳理</a>
          </li>
        
          <li>
            <a href="/2018/03/05/redis/">redis数据结构</a>
          </li>
        
          <li>
            <a href="/2018/03/04/学习计划/">学习计划</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 hfq<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>